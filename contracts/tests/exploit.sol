pragma solidity ^0.4.0;

import 'erc20/base.sol';
import 'tests/base.sol';

contract MaliciousToken is ERC20Base {
    TestableManager _manager;
    uint _auctionlet_id;
    uint _bid_how_much;
    uint _quantity;

    enum Attack {Off, Bid, Split, Claim, Done}
    Attack attack = Attack.Off;

    function MaliciousToken(uint initial_balance)
        ERC20Base(initial_balance)
        {}
    function setTarget(address manager) {
        _manager = TestableManager(manager);
    }
    function setID(uint id) {
        _auctionlet_id = id;
    }
    function setBid(uint bid_how_much) {
        _bid_how_much = bid_how_much;
    }
    function setQuantity(uint quantity) {
        _quantity = quantity;
    }
    function attackBid() {
        attack = Attack.Bid;
    }
    function attackSplit() {
        attack = Attack.Split;
    }
    function attackClaim() {
        attack = Attack.Claim;
    }
    function attackOff() {
        attack = Attack.Off;
    }
    function attackDone() {
        attack = Attack.Done;
    }
    function transferFrom(address from, address to, uint amount)
        returns (bool ok)
    {
        if (attack == Attack.Done) {
            return true;
        } else if (attack == Attack.Bid) {
            attackDone();
            _manager.bid(_auctionlet_id, _bid_how_much, _quantity);
        } else if (attack == Attack.Split) {
            attackDone();
            _manager.bid(_auctionlet_id, _bid_how_much, _quantity);
        } else {
            super.transferFrom(from, to, amount);
        }
        return true;
    }
    function transfer(address to, uint amount)
        returns (bool ok)
    {
        if (attack == Attack.Done) {
            return true;
        } else if (attack == Attack.Claim) {
            attackDone();
            _manager.claim(_auctionlet_id);
            return true;
        } else {
            return super.transfer(to, amount);
        }
    }
}

contract ExploitTest is AuctionTest {
    MaliciousToken mtoken;
    uint constant TM = 5 ** 9;

    function newMaliciousBidAuction() returns (uint, uint) {
        return manager.newAuction( seller    // beneficiary
                                 , t1        // selling
                                 , mtoken    // buying
                                 , 100 * T1  // sell_amount
                                 , 10 * TM   // start_bid
                                 , 1         // min_increase (%)
                                 , 1 years   // ttl
                                 );
    }
    function newMaliciousClaimAuction() returns (uint, uint) {
        return manager.newAuction( seller    // beneficiary
                                 , mtoken    // selling
                                 , t2        // buying
                                 , 100 * TM  // sell_amount
                                 , 10 * T2   // start_bid
                                 , 1         // min_increase (%)
                                 , 1 years   // ttl
                                 );
    }
    function exploitSetUp () returns (uint) ;
    function testSetUp() {
        exploitSetUp();
    }
}

contract BidExploitTest is ExploitTest {
    function exploitSetUp () returns (uint) {
        mtoken = new MaliciousToken(10 ** 6 * TM);
        var (id, base) = newMaliciousBidAuction();

        mtoken.setTarget(manager);
        mtoken.setID(base);
        mtoken.setBid(30 * TM);
        mtoken.setQuantity(100 * T1);
        mtoken.attackBid();
        return base;
    }
    function testFailReEntrantBid() {
        var base = exploitSetUp();
        manager.bid(base, 20 * TM, 100 * T1);
    }
}

contract SplitExploitTest is ExploitTest {
    function exploitSetUp () returns (uint) {
        mtoken = new MaliciousToken(10 ** 6 * TM);
        var (id, base) = newMaliciousBidAuction();

        mtoken.setTarget(manager);
        mtoken.setID(base);
        mtoken.setBid(30 * TM);
        mtoken.setQuantity(50 * TM);
        mtoken.attackSplit();
        return base;
    }
    function testFailReEntrantSplit() {
        var base = exploitSetUp();
        manager.bid(base, 20 * TM, 80 * T1);
    }
}

contract ClaimExploitTest is ExploitTest {
    function exploitSetUp () returns (uint) {
        mtoken = new MaliciousToken(10 ** 6 * TM);
        mtoken.approve(manager, 100 * TM);
        var (id, base) = newMaliciousClaimAuction();

        mtoken.setTarget(manager);
        mtoken.setID(base);

        manager.bid(base, 20 * T2, 100 * TM);
        manager.addTime(2 years);

        mtoken.attackClaim();
        return base;
    }
    function testFailReEntrantClaim() {
        var base = exploitSetUp();
        manager.claim(base);
    }
}
